// Generated by CoffeeScript 1.6.1

/*
mintpresso-0.2.coffee

Author: Jinhyuk Lee <eces at mstock.org>
Organization: MINTPRESSO <support at mintpresso.com>
Repository: https://github.com/mintpresso/javascript-api

Description:
  This is a JavaScript API library for MINTPRESSO Data Cloud.
  Supports basic graph operations.

Documentation: docs.mintpresso.com/javascript-api/index.html
*/


(function() {
  var addEdge, addPoint, client, feature, findEdges, getPoint, getPointByTypeOrIdentifier, model, prefix, server;

  if (String.prototype.format === void 0) {
    String.prototype.format = function() {
      var _arguments;
      _arguments = arguments;
      return this.replace(/{(\d+)}/g, function(match, number) {
        if (typeof _arguments[number] !== 'undefined') {
          return _arguments[number];
        } else {
          return match;
        }
      });
    };
  }

  String.prototype.endsWith = function(suffix) {
    return this.substr(this.length - suffix.length) === suffix;
  };

  String.prototype.startsWith = function(prefix) {
    return this.substr(0, prefix.length) === prefix;
  };

  try {
    prefix = {
      log: '[MINTPRESSO] ',
      version: '/v1'
    };
    client = {
      name: 'JS 0.2 API',
      key: '',
      id: '',
      useDebugCallback: true,
      getAPI: function() {
        return 'api_token=' + client.key;
      }
    };
    server = {
      list: [],
      iteration: 0,
      get: function() {
        return server.list[server.iteration];
      },
      isReady: false,
      timeout: 5000,
      urls: {
        getPoint: "/account/{0}/point/{1}?",
        getPointByTypeOrIdentifier: "/account/{0}/point?type={1}&identifier={2}&",
        addPoint: "/post/account/{0}/point?updateIfExists={1}&",
        findEdge: "/account/{0}/edge?subjectId={1}&subjectType={2}&subjectIdentifier={3}&verb={4}&objectId={5}&objectType={6}&objectIdentifier={7}&getInnerModels={8}&",
        linkWithEdge: "/post/account/{0}/edge?subjectId={1}&subjectType={2}&subjectIdentifier={3}&verb={4}&objectId={5}&objectType={6}&objectIdentifier={7}&getInnerModels={8}&"
      },
      dataType: 'jsonp',
      useCallback: true,
      callbackName: 'JSAPIMINTPRESSOCALLBACK'
    };
    feature = {
      pageTracker: false
    };
    model = {
      verbs: new Array('do', 'does', 'did', 'verb'),
      mark: '?',
      point: {
        prototype: new Array('type', 'identifier', 'data')
      },
      edge: {
        prototype: new Array('subjectId', 'subjectType', 'verb', 'objectId', 'objectType')
      }
    };
    getPoint = function(id, callback) {
      return jQuery.ajax({
        url: server.get() + prefix.version + server.urls.getPoint.format(client.id, id) + client.getAPI(),
        type: 'GET',
        async: true,
        cache: false,
        crossDomain: true,
        dataType: server.dataType,
        jsonpCallback: server.callbackName,
        timeout: server.timeout,
        success: function(json) {
          var data, key;
          data = void 0;
          if (json.status.code === 200) {
            if (json.point.data !== void 0) {
              for (key in json.point.data) {
                if (key !== 'data') {
                  json.point[key] = json.point.data[key];
                } else {
                  data = json.point.data[key];
                }
              }
              if (data === void 0) {
                delete json.point.data;
              } else {
                json.point.data = data;
              }
            }
          }
          return callback(json);
        },
        error: function(xhr, status, error) {
          console.error("" + prefix.log + " Response(" + status + ") " + error);
          return callback({
            status: {
              code: status,
              message: "Response(" + status + ") " + error
            }
          });
        }
      });
    };
    getPointByTypeOrIdentifier = function(json, callback) {
      var i, key, _identifier, _type;
      i = 0;
      _type = "";
      _identifier = "";
      for (key in json) {
        if (i > 0) {
          console.log("" + prefix.log + "Too many arguments are given to be an informative query though no question marks are found - mintpresso.get");
          break;
        }
        if (key.length === 0 || key !== model.mark) {
          _type = encodeURIComponent(key);
        }
        if (json[key].length === 0 || json[key] === model.mark) {
          console.log(prefix.log + ("" + prefix.log + "No question mark is allowed on 'identifier' field - mintpresso.get"));
          return false;
        } else {
          _identifier = encodeURIComponent(json[key]);
        }
        i++;
      }
      return jQuery.ajax({
        url: server.get() + prefix.version + server.urls.getPointByTypeOrIdentifier.format(client.id, _type, _identifier) + client.getAPI(),
        type: 'GET',
        async: true,
        cache: false,
        crossDomain: true,
        dataType: server.dataType,
        jsonpCallback: server.callbackName,
        timeout: server.timeout,
        success: function(json) {
          var data, point, _i, _ref;
          data = void 0;
          if (json.status.code === 200) {
            if (json.point !== void 0) {
              if (json.point.data !== void 0) {
                for (key in json.point.data) {
                  if (key !== 'data') {
                    json.point[key] = json.point.data[key];
                  } else {
                    data = json.point.data[key];
                  }
                }
                if (data === void 0) {
                  delete json.point.data;
                } else {
                  json.point.data = data;
                }
              }
            } else if (json.points !== void 0) {
              for (i = _i = 0, _ref = json.points.length - 1; _i <= _ref; i = _i += 1) {
                point = json.points[i];
                if (point.data !== void 0) {
                  for (key in point.data) {
                    if (key !== 'data') {
                      json.points[i][key] = point.data[key];
                    } else {
                      data = point.data[key];
                    }
                  }
                  if (data === void 0) {
                    delete json.points[i].data;
                  } else {
                    json.points[i].data = data;
                  }
                }
              }
            } else {
              console.error(prefix.log + "Found results neither point nor points - mintpresso._getPointByTypeOrIdentifier");
            }
          }
          return callback(json);
        },
        error: function(xhr, status, error) {
          console.error("" + prefix.log + " Response(" + status + ") " + error);
          return callback(JSON.parse(xhr.responseText));
        }
      });
    };
    findEdges = function(json, callback, getInnerModels) {
      var i, key, oId, oString, oType, sId, sString, sType, v;
      if (getInnerModels == null) {
        getInnerModels = false;
      }
      i = 1;
      sType = '';
      sId = -1;
      sString = '';
      v = '';
      oType = '';
      oId = -1;
      oString = '';
      for (key in json) {
        switch (i) {
          case 1:
            sType = encodeURIComponent(key);
            if (json[key] !== model.mark && typeof json[key] === 'number') {
              sId = encodeURIComponent(json[key]);
            }
            if (json[key] !== model.mark && typeof json[key] === 'string') {
              sString = encodeURIComponent(json[key]);
            }
            break;
          case 2:
            if (model.verbs.indexOf(key) === -1) {
              console.log(prefix.log + 'Verb isn\'t match with do/does/did/verb. - mintpresso.get');
            } else {
              if (json[key] !== model.mark) {
                v = encodeURIComponent(json[key]);
              }
            }
            break;
          case 3:
            oType = encodeURIComponent(key);
            if (json[key] !== model.mark && typeof json[key] === 'number') {
              oId = encodeURIComponent(json[key]);
            }
            if (json[key] !== model.mark && typeof json[key] === 'string') {
              oString = encodeURIComponent(json[key]);
            }
            break;
          default:
            console.log(prefix.log + 'Too many arguments are given to be a form of subject/verb/object query - mintpresso.get');
            return false;
        }
        i++;
      }
      return jQuery.ajax({
        url: server.get() + prefix.version + server.urls.findEdges.format(client.id, sId, sType, sString, v, oId, oType, oString, getInnerModels) + client.getAPI(),
        type: 'GET',
        async: true,
        cache: false,
        crossDomain: true,
        dataType: server.dataType,
        jsonpCallback: server.callbackName,
        timeout: server.timeout,
        success: function(json) {
          return callback(json);
        },
        error: function(xhr, status, error) {
          console.error("" + prefix.log + " Response(" + status + ") " + error);
          return callback(JSON.parse(xhr.responseText));
        }
      });
    };
    addPoint = function(json, callback, updateIfExists) {
      var key, value;
      if (updateIfExists == null) {
        updateIfExists = false;
      }
      value = {};
      value.point = {};
      value.point.data = {};
      for (key in json) {
        if (model.point.prototype.indexOf(key) !== -1) {
          value.point[key] = json[key];
        } else {
          value.point.data[key] = json[key];
        }
      }
      return jQuery.ajax({
        url: server.get() + prefix.version + server.urls.addPoint.format(client.id, encodeURIComponent(JSON.stringify(value), updateIfExists)) + client.getAPI(),
        type: 'GET',
        async: true,
        cache: false,
        crossDomain: true,
        dataType: server.dataType,
        jsonpCallback: server.callbackName,
        timeout: server.timeout,
        success: function(json) {
          return callback(json);
        },
        error: function(xhr, status, error) {
          console.error("" + prefix.log + " Response(" + status + ") " + error);
          return callback(JSON.parse(xhr.responseText));
        }
      });
    };
    addEdge = function(json, callback) {
      var i, key, value;
      value = {};
      value.edge = {};
      i = 1;
      for (key in json) {
        switch (i) {
          case 1:
            if (key !== model.mark && model.edge.prototype.indexOf(key) === -1) {
              value.edge.subjectType = key;
            }
            if (json[key] !== model.mark) {
              value.edge.subjectId = json[key];
            }
            break;
          case 2:
            if (model.verbs.indexOf(key) === -1) {
              console.log("" + prefix.log + " Verb isn\'t match with do/does/did/verb. - mintpresso.set");
            } else {
              value.edge.verb = json[key];
            }
            break;
          case 3:
            if (key !== model.mark && model.edge.prototype.indexOf(key) === -1) {
              value.edge.objectType = key;
            }
            if (json[key] !== model.mark) {
              value.edge.objectId = json[key];
            }
            break;
          default:
            console.log("" + prefix.log + " Too many arguments are given to be a form of subject/verb/object query - mintpresso.set");
            return false;
        }
        i++;
      }
      return jQuery.ajax({
        url: server.get() + prefix.version + server.urls.linkWithEdge.format(client.id, encodeURIComponent(JSON.stringify(value))) + client.getAPI(),
        type: 'GET',
        async: true,
        cache: false,
        crossDomain: true,
        dataType: server.dataType,
        jsonpCallback: server.callbackName,
        timeout: server.timeout,
        success: function(json) {
          return callback(json);
        },
        error: function(xhr, status, error) {
          console.error("" + prefix.log + " Response(" + status + ") " + error);
          return callback(JSON.parse(xhr.responseText));
        }
      });
    };
    window.mintpresso = {};
    window.mintpresso = {
      get: function() {
        /*
        @param
          Object json, Function callback[, Boolean getInnerModels = false]
        */

        var callback, conditions, getInnerModels, hasMark, json, key;
        if (server.isReady === false) {
          return console.warn("" + prefix.log + "Not initialized. Add mintpress.init in your code with API key.");
        }
        if (arguments.length === 0) {
          return console.warn("" + prefix.log + "An argument is required for mintpresso.get method.");
        } else if (arguments.length <= 2) {
          getInnerModels = false;
          if (arguments[2] !== void 0 && typeof 'boolean') {
            getInnerModels = true;
          } else {
            getInnerModels = false;
          }
          if (arguments[1] !== void 0 && typeof arguments[1] === 'function') {
            callback = arguments[1];
          } else {
            callback = window.mintpresso.callback;
          }
          if (typeof arguments[0] === 'number') {
            return getPoint(arguments[0], callback);
          } else if (typeof arguments[0] === 'object') {
            json = arguments[0];
            hasMark = false;
            conditions = 0;
            for (key in json) {
              conditions++;
              if (key === "?" || json[key] === "?") {
                hasMark = true;
              }
            }
            if ((hasMark && conditions > 1) || conditions === 3) {
              return findEdges(arguments[0], callback, getInnerModels);
            } else {
              return getPointByTypeOrIdentifier(arguments[0], callback);
            }
          } else {
            return console.warn("" + prefix.log + " An argument type of Number or String is required for mintresso.get method.");
          }
        } else {
          return console.warn("" + prefix.log + " Too many arguments in mintpresso.get method.");
        }
      },
      set: function() {
        /*
        @param
          Object json[, Function callback[, Boolean updateIfExists = false]]
        */

        var callback, isEdgeOperation, key, updateIfExists;
        if (server.isReady === false) {
          return console.warn("" + prefix.log + "Not initialized. Add mintpress.init in your code with API key.");
        }
        if (arguments.length === 0) {
          console.warn("" + prefix.log + "An argument is required for mintpresso.set method.");
        } else if (arguments.length <= 3) {
          if (typeof arguments[0] === 'object') {
            isEdgeOperation = false;
            for (key in arguments[0]) {
              if (model.verbs.indexOf(key) !== -1) {
                isEdgeOperation = true;
                break;
              }
            }
            updateIfExists = false;
            callback = window.mintpresso.callback;
            if (arguments[1] !== void 0) {
              if (typeof arguments[1] === 'function') {
                callback = arguments[1];
                if (arguments[2] !== void 0 && typeof arguments === 'boolean') {
                  updateIfExists = true;
                }
              }
            }
            if (isEdgeOperation === true) {
              addEdge(arguments[0], callback);
            } else {
              if (arguments[1] === void 0 || arguments[1] === false) {
                addPoint(arguments[0], callback, updateIfExists);
              } else {
                addPoint(arguments[0], callback, updateIfExists);
              }
            }
          } else {
            console.warn("" + prefix.log + "An JSON object is required for mintpresso.set method.");
          }
        } else {
          console.warn("" + prefix.log + "Too many arguments in mintpresso.get method.");
        }
        return true;
      },
      callback: function(response) {
        var _ref;
        if (client.useDebugCallback === true) {
          if ((response != null ? (_ref = response.status) != null ? _ref.code : void 0 : void 0) > 201) {
            return console.log("" + prefix.log + "Response(" + response.status.code + "): " + response.status.message, response);
          } else {
            return console.log("" + prefix.log + "Response(" + response.status.code + "): ", response);
          }
        }
      },
      init: function(key, id, option) {
        var domain;
        if (typeof key !== 'string') {
          return console.warn("" + prefix.log + " Not initialized. Invalid API key. (required: String)");
        }
        client.key = key;
        client.id = id;
        if (option.withoutCallback !== void 0 && option.withoutCallback === true) {
          server.dataType = 'json';
          server.callbackName = void 0;
          server.useCallback = false;
        } else {
          server.useCallback = true;
        }
        domain = '//api.mintpresso.com';
        if (option.useLocalhost !== void 0 && option.useLocalhost === true) {
          console.log("" + prefix.log + "Using localhost server (http://localhost:15100)");
          domain = '//localhost:15100';
        }
        if ('https:' === document.location.protocol) {
          server.list.push('https:' + domain);
        } else {
          server.list.push('http:' + domain);
        }
        if (option.callbackFunction !== void 0 && option.callbackFunction.length > 0 && option.callbackFunction in window) {
          window[option.callbackFunction](window.mintpresso);
          console.log("" + prefix.log + "window." + option.callbackFunction + " is called.");
        }
        if (option.disableDebugCallback !== void 0 && option.disableDebugCallback === true) {
          client.useDebugCallback = false;
        } else {
          client.useDebugCallback = true;
        }
        server.isReady = true;
        return true;
      }
    };
  } catch (e) {
    if (window.mintpresso !== void 0 && true) {
      throw e;
    } else {
      console.warn("" + prefix.log + " Failed to load API.");
    }
  }

  true;

}).call(this);
